# 누적 차용 이해하기 (Attempting To Understand Stacked Borrows)

이전 섹션에서 우리는 Miri(미리)를 통해 우리의 unsafe 단방향 연결 큐(singly-linked queue)를 실행하려 시도했고, Miri는 우리가 *누적 차용(stacked borrows)* 이라는 규칙을 위반했다며 관련 공식 문서를 던져주었습니다.

보통이라면 제가 그 문서들을 천천히 안내하며 같이 투어(tour)를 돌았겠죠, 하지만 이번 문서의 타깃 주요 독자층(target audience)은 평범한 서민 프로그래머가 아닙니다. 저건 사실상 Rust 언어 생태계 기저의 의미론 규칙 구조(semantics of Rust) 파운데이션을 밑바닥부터 파고 뜯어고쳐 설계하는 학자들과 천재 컴파일러 엔지니어 개발자 집단을 위한 전공 학술 원론에 가깝습니다.

그래서 저는 여기서 "누적 차용(stacked borrows)"의 핵심적인 거시 세계 관념(high level *idea*) 정도만 슬쩍 가볍게 읊어드린 뒤, 여러분이 그 무서운 규율을 무사히 준수해 나갈 수 있는 심플한 대응 전략 전술(simple strategy) 몇 가지만 던져주고 넘어가려 합니다.

> **해설자:** '누적 차용(Stacked borrows)'이란 개념 자체는 Rust 내에서 여전히 의미론적 기초 모델 체계(semantic model)로서 "실험 단계(experimental)"에 불과합니다. 따라서 당장 오늘 이 규칙을 위반했다고 해서 당신의 프로그램이 100% 무조건 망한 "틀린(wrong)" 코드라는 단호한 판정을 내리긴 어렵습니다. 하지만 만약 당신이 진짜 컴파일러 파운데이션 코어 개발자(literally work on the compiler)급 되는 비범한 인재가 아니라면, 웬만하면 평화롭게 얌전히 그냥 miri가 불평하고 불평댈 때 군말 없이 무조건 수긍하고 고치십쇼(fix your program). 미정의 동작(Undefined Behaviour) 귀신 앞에서는 고집 부리며 후회하는(sorry) 것보단 걍 바짝 엎드려 목숨 부지하며 안전빵(safe) 치는 게 언제나 최선의 상책입니다.



# 원동력: 포인터 앨리어싱 (The Motivation: Pointer Aliasing)

우리가 구체적으로 무슨 어불성설 *무슨 짓(what* rules)* 을 저질러 위반 사태가 났는지 깊이 따져보기 전에, 애당초 대체 왜 이런 피곤한 규제(rules exist)가 기어코 세상에 태어난 것인지 그 근원 배경(*why*) 원인 사유부터 파악하는 게 정신 건강에 큰 도움이 될 겁니다. 여러 복합 복잡 다양한 동기부여 명분(motivating problems) 트리거 발생 문제점들이 얽혀 있긴 하지만, 제 개인적으론 가장 핵심 원흉 원죄는 단연코 저 망할 *포인터 앨리어싱(pointer aliasing)* 이라고 단언합니다.

두 포인터가 서로 *앨리어스(alias)* 되었다는 말은 두 녀석이 가리키는 포인터 위치 주소 영토 메모리 파편 덩어리 영역 공간이 완전히 서로 교차 겹친다는(overlap) 뜻입니다. 마치 누군가가 "가명 신분 세탁(goes by an alias)"을 하여 한 명의 동일 인물을 두 개의 다른 이름 간판으로 동시에 지칭 호출(referred to by two different names)해 부를 수 있듯, 동일한 메모리 구역 하나가 겹친 채 두 개의 각기 다른 포인터 사령관에 의해 동시 원격 호출 지칭 명령 대상(referred to by two different pointers)으로 지정되는 기이한 현상입니다. 당연히 이런 구조는 파국 문제(problems)를 불러오기 딱 좋죠.

컴파일러는 포인터들의 앨리어스 동기화 매핑 겹침 구조 설계도 상황 인포메이션 정보(information about pointer aliasing)를 십분 활용해 메모리 접근 쾌속 최적화 고속 튜닝 처리 로직(optimize accesses)을 수립 채택 발동합니다. 그런데 만약 컴파일러가 쥔 그 사전 족보 정보가 근본부터 썩은 *오류(wrong)* 허상이었다면, 프로그램은 개판으로 오폭 빌드 오역 컴파일(miscompiled)되어 황당한 듯 임의의 형편없는 것 난동 짓거리(do random garbage)를 자행하게 될 겁니다.

> **해설자:** 아주 현실적인 실무 관점(Practically speaking)으로 비틀어 얘기하자면, 앨리어싱이라는 개념은 그 포인터 자체의 본질보다는 정작 어떻게 그 영토에 진입 침투 점령 메모리에 접근하느냐(memory accesses) 방식에 훨씬 더 치명적 비중의 초점이 맞춰져 있으며, 그중에서도 특정 접근 노선 조작 중 무언가 적어도 한 곳이 가변 수정 조작(mutating) 기동을 벌이려 할 때 진짜로 황당한 파국 극성 영향을 끼칩니다(only really matters). 포인터라는 감투가 유독 눈에 띄게 강조 강조 부각 지목(emphasized) 받는 이유는 그저 규칙 통제 규율이란 사슬을 걸어 붙잡아 매달아 통치하기에 가장 편리 찰떡 핑곗거리 대상 명분 꼬리표(convenient thing) 명함이기 때문입니다.

포인터 앨리어스 지형 요도 지침 정보라는 게 대체 왜 그렇게 세상 소중하고 끔찍 막대(important) 한 건지 깊이 음미하기 위해, 지금부터 *작고 화난 사나이의 우화 (The Parable of the Tiny Angry Man)* 이야기를 들려드리겠습니다.

----

어느 날 한적한 오후, 미힐(Michiel)은 자신의 고상한 서재 책장(bookshelf) 구석을 이리저리 뒤적거리다 도무지 시킨 적도 본 적도 없는 생경한 책 한 권(didn't remember)을 문득 발견했습니다. 미힐은 조심스레 서가 한 켄 기둥 사이에서 그 수상한 책을 끄집어 올려 빼들곤(pulled it) 유심히 겉표지(cover) 제목을 살폈습니다.

"아, 이런 그렇군! 내가 진짜 감명 깊게 전부 독파해 정복 완독해 버린 나의 소중 찬란한 고전문학 마스터피스 도서 수집 소장본 *전쟁과 평화(War and Peace)* 였잖아. 난 정말이지 그 책 속에서 모든 분쟁이 사라진 그 순백 완전한 엄청난 대량의 평화(Peace) 구절 장막 대목들이 진심으로 너무 좋았어."

그때 냅다 현관문 지축이 흔들리게 쾅쾅 노크 소리 부름 호출(knock at the door)이 요란하게 울려 퍼졌습니다. 미힐은 가볍게 콧방귀를 뀌곤 무심한 듯 시크하게 그 책을 대충 원래 꽂혀 있던 12번 책장 구멍 선반(shelf) 사이에 다시 스윽 쑤셔 넣곤 슬그머니 발길을 돌려 현관 문턱 자물쇠를 돌려 따 열어 젖혔습니다(opened the door) -- 그곳 앞엔 다름 아닌, 그토록 철천지원수이자 평생의 숙적, 웬수 덩어리인 <b>햄슬로(Hamslaw)</b> 가 바락 아귀 두 눈을 치켜뜬 채 무장 대기로 떡하니 버티고 섰었죠. 우리의 빌런 햄슬로 양은 다짜고짜 미힐의 가소로울 만치 참담 형편없이 후진 초라 빈약 코드 골프 축소 코딩 코더 짜내기 조립 타건 솜씨력 타작 한계를 잔혹히 후벼 파 비수 벼린 치명 조롱 악담(devastating remark about Michiel's clearly inferior codegolfing skills)을 시전 날려 방아쇠를 댕기기 위해 심호흡 장전을 거친 완벽 세팅 상태였습니다만, 정작 우리의 수비수 미힐은 오히려 이 위기를 승기로 뒤엎을 번뜩이는 선빵 회피 기회 통로(sensed an opening) 빈틈 틈새 활로를 포착 캐치해 냅니다:

"어이, 이 비루한 패배자 햄슬로 녀석아, 너 행여 살면서 단 한 번이라도 저 위대하신 고전 대명작 대작 도서 *전쟁과 평화(War and Peace)* 따윌 곁눈질로 제대로 정독 구경 읽어나 본 적(ever read)은 있으시냐?"

"푸흡, 야 이 웃기는 소리 뻘소리 지껄이는 얼간아(Pfft). 이 세상천지에 제정신 맑고 제정신 박힌 녀석 치고 그딴 지루한 낡은 고물 수면제 소설책 *전쟁과 평화* 따위를 *진짜로 리얼 팩트 각 잡고 완독 클리어(actually* read)* 해낸 수재 인간 녀석가 존재하긴 하냐?"

"그럼, 내가 당장 바로 여깄잖아. 저길 보시지, 야 이 코앞에 저기 내 개인 도서 컬렉션 책장에 아주 늠름 당당히 떡하니 모셔 비치 전시 박제 방치 꽂혀 보존 안치(right there in my bookcase) 돼 있는 웅장 위엄 자태 안 보이냐? 저게 있다는 건 *아주 너무나도 지극히 단연코 명백 뻔하게 팩트 입증(*obviously*)* 내가 완벽 통달 소화 전부 일독 다 마스터 완독 독파(I've read it) 했다는 반박 불가 불가의 유일 진리 아니겠어?"

햄슬로는 너무 어이가 없었습니다. 그녀 특유의 얄미운 미소는 곧 분노로 바뀌었습니다. 그녀는 미힐을 옆으로 밀쳐내고 성큼성큼 책장으로 다가가, 묵직한 책을 홱 끄집어냈습니다. 책을 뒤집어 앞표지를 본 순간, 그녀는 파르르 떨기 시작했습니다.

미힐이 자신의 압도적 지성을 뽐내려던 찰나, 갑자기 햄슬로의 호탕한 웃음소리가 적막을 깼습니다.

"푸하하하하 이게 전쟁과 평화라고? 풉ㅋㅋㅋ 여기 똑똑히 봐, 제목이 전쟁과 **발(War and *Feet*)** 이잖아 ㅋㅋㅋ!"

햄슬로의 뺨을 타고 기쁨의 눈물이 흘러내렸습니다. 단언컨대 그녀의 인생 최고의 순간 중 하나임이 분명했습니다.

"아, 아니! 말도 안 돼! 내가 방금 눈으로 똑똑히 확인했는데!"

미힐은 햄슬로의 손에서 책을 홱 빼앗아 표지를 다시 살폈습니다. 아니나 다를까, '평화(Peace)'라는 단어는 펜으로 마구 긁혀 지워져 있었고, 그 자리에 조잡한 글씨로 '발(Feet)'이라고 덧씌워져 있었습니다. 미힐은 그 자리에서 극도의 수치심에 얼어붙고 말았습니다. 인생 최악의 순간이었습니다.

미힐은 털썩 무릎을 꿇고 멍하니 책장을 바라보았습니다. 도대체 어떻게 이런 일이 일어날 수 있단 말인가? 불과 몇 분 전에 확인했을 때만 해도 분명히 '평화'였는데!

그리고 바로 그 순간, 책장 틈새에서 뭔가 미세한 움직임이 보였습니다. 그곳에는 이제껏 본 적 없는 잔뜩 성이 난 작은 사나이(a tiny man)가 어둠 속에 숨어 있었습니다. 그는 미힐을 향해 가운뎃손가락을 쳐들더니, 소리 없이 입모양으로 "아무도 네 말을 믿어주지 않을걸"이라고 속삭이고는 책장 뒤로 쏙 사라졌습니다.

미힐의 계획은 완벽했습니다. 단지 매직펜 하나를 들고 파괴 본능에 휩싸인 아주 작고 화난 사나이의 개입 가능성을 미처 계산하지 못했을 뿐입니다. 그들은 자신들이 모든 것을 알고 통제할 수 있다고 자신했죠. 어느 누구도 감히 간섭하지 못할 거라고 굳게 믿었습니다. 하지만 안타깝게도, 그들은 틀렸습니다.

***

아무도 저 화난 작은 사나이의 희생양이 되고 싶지 않을 겁니다. 이 포인터 앨리어싱이 문제가 되는 것은, 컴파일러가 언제 저 "화난 작은 사나이"의 난입 걱정 없이 안전하게 최적화를 수행할 수 있는지 명확히 알고 싶어 하기 때문입니다.

> **해설자:** 컴파일러는 이 정보를 스토어(writes) 캐싱 최적화에서도 쓰며, 값을 굳이 매번 램에 안 박아 넣어도 안전하다 여겨지면 바로 메모리 출납을 스킵합니다.


# 안전한 누적 차용 (Safe Stacked Borrows)
Rust는 애초에 이 문제를 잡으려고 디자인되었습니다. 가변 참조(`&mut`)는 정의에 따라 절대 앨리어스가 생길 수 없으며, 공유 참조(`&`)는 앨리어스 되어봤자 읽기 전용이므로 아무런 문제가 없습니다. 완벽하죠! 출시합시다!

문제는 Rust의 "재차용(reborrow)" 문법입니다.

```rust
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1; // <--- 요게 재차용입니다

*ref2 += 2;
*ref1 += 1;

println!("{}", data);
```

이건 컴파일이 되는데, 아래처럼 순서를 꼬면 에러가 납니다:

```rust ,ignore
// ORDER SWAPPED!
*ref1 += 1;
*ref2 += 2;
```

에러의 원인은 가변 포인터를 재차용(reborrow) 한 그 즉시부터, 두 번째 재차용자(`ref2`)가 모든 행동을 끝마칠(no more uses) 때까지 원본 포인터(`ref1`)는 철저히 동결 잠금 접근 통제 차단(can't be used anymore) 되기 때문입니다.
이 논리를 구현하기 위해 Rust는 각 메모리 영역마다 허가증을 담는 작은 탑 구획인 '차용 스택(borrow stack)'을 세워 관리합니다. 이것이 바로 **Stacked Borrows (누적 차용)** 입니다!
스택 맨 위(top)에 꽂힌 녀석만이 '활성(live)' 취급받으며 유일한 배타적 접근 권한을 쥡니다. 새로운 재차용을 생성하면 새 허가증이 스택 위에 쌓이고(`push`), 예전 낡은 원본 포인터를 다시 들이밀어 사용하면 컴파일러는 "어? 밑에 있는 구형 포인터를 쓰네? 그럼 이 위에 쌓인 최신 재차용들은 다 쓸모 없어졌군" 하고 스택 윗선들을 싹 다 폭파 증발 날려버립니다(`popping everything`). 
문제가 터지는 지점은 바로 방금 전처럼 팝업 되어 증발 날아가 버린(popped off) 무효화된 폐기물 형편없는 것 포인터를 또다시 몰래 슬쩍 우겨 들이밀어 접근(accessing a pointer)할 때 발생합니다 -- 그게 바로 당신이 파국을 낸(messed up) 원흉이죠. 


# 불안전한 누적 차용 (Unsafe Stacked Borrows)
문제는 이 훌륭하고 엄격한 차용 검사기(borrowchecker) 선생님께서 안전하지 않은 원시 포인터(unsafe pointers)들을 보게 되는 순간 완전 장님이 되어 통제력을 상실해버린단 점입니다!
우린 원시 포인터도 이 누적 차용 스택 시스템(stacked borrows system)의 가이드라인 통제 울타리 보호판에 소속시키고 싶습니다.
매우 추상적인 큰 그림(very high-level concept) 논조로 봤을 때, 당신이 안전 참조자(reference)를 원시 포인터(raw pointer)로 다운 캐스팅 강등 변환 교배 도출시키는 행위 조작 절차는 개념상 본질 근본 토대 성격 구조(basically) 재차용 파생 발급 절차(taking a reborrow) 허가증과 완벽히 동치 똑같은 구조 절차입니다. 고로 원시 포인터로의 이양 양도가 완료 성사 발급 개시되면 그 즉시 원시 포인터 측에게는 허가증이 교부 승인 하락되어 온갖 황당한 야생 자유 변조 접근 열람 훼손 조작(allowed to do whatever it wants) 등 난무 생쇼 막장 파티 권한이 일시로 떨어지며, 차후 이 계약 기일 대출 잔여 생태가 종말 파기 소멸 멸종(expires) 파산 증발 끝나는 즉시는 일반 정석 참조 융자 소멸 절차 로직 강령 수칙과 소름 돋게 흡사 완벽 동일 유사 동치 일치 조응 매칭 대조 규격(just like when that happens with normal reborrows) 적용 귀속 제재가 적용 판결 집행 도출 판별 발동 구동 가동 작용 성사 됩니다.

그럼 대체 언제 그 원시 포인터로 발급된 황당한 허가증 기간이 소멸 마감 파기 말소 만료(expire) 되냐고요? 글쎄요, 아마 가장 유력 합리 지당 타당 확실 정배 확실한 시점(good time) 종말 조건은, 당신이 옛날 조상 오리지널 안전 거울 증표 원본 안전 규격 참조 포인터를 슬그머니 기어코 다시 재차 꺼내 발굴 시전 소환 구동 들이대 사용할(start using the original reference again) 무렵일 겁니다.

근데 잠깐만요, 그럼 원시 포인터를 무단 복사하거나 아니면 거꾸로 안전 참조자로 올려버리면(turn a raw pointer *into* a reference)요? 예를 들어 `&mut -> *mut -> &mut -> *mut` 이따위로 교배식을 진행하고 첫 번째 `*mut`을 건드려버리면 그땐 이 망할 누적 차용 스택이 어떻게 꼬이고 굴러가는 겁니까(how the heck)?
저도 모릅니다(I genuinely don't know)! 그래서 이 모습가 이렇게 심히 복잡하고 더러운 거(complicated)죠.

이 끔찍한 더러운 혼란 파국 막장 사태 구역 대혼돈 오염 진흙 카오스(messiness)야말로 미리(miri) 님께서 친히 실험용 극초정밀 극악 가차 초강 수위 매운맛 철검 극딜 매운맛 사형 결벽 무결 모드 옵션(`-Zmiri-tag-raw-pointers`)을 따로 추가로 탑재 하사 남겨두신 이유기도 합니다.
윈도우 환경에선 아래처럼 켜볼 수 있습니다:
```text
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo +nightly-2022-01-21 miri test
```


# 누적 차용 관리하기 (Managing Stacked Borrows)
이 무지막지 까다롭고 위험수위 극악한 원시 포인터 지뢰 바닥 원시 시대 야생 정글 맹수 판에서 무사히 안전 지향 보존 수명 연장 보험 방어 최소 면책 특권 자가 면피 회피 생존 연명 유지(stick to a heuristic)를 달성 지속 영위 실현 방호 무사 안일 유지 지키려면 부디 통제 심플 기조 강령 이 단순 하나 철칙 원칙 기조 노선 단 한 줄만(simple and blunt) 명심하고 받들어 따져 지키십시오:

**일단 한 번 원시 포인터(raw pointers)의 타락 늪 세계 영역 수단으로 전환 입수 탑승 강타 진입 도달 타락(Once you start using) 하셨다면, 이왕 그래 된 거 이후엔 죽이 되든 밥이 되든 무조건 그냥 온리 오직 결단 끝까지 뚝심 일편 단심 굳게(try to ONLY use) 원시 포인터만을 맹목 애용 붙잡 쥐고 사용해 부딪쳐라.**

> **해설자:** 안전 참조자(`safe pointers`)는 단순히 앨리어싱 금지만 규제하는 게 아니라 메모리 점유 크기 할당 할당 이력 상태 안정성(allocated), 유효 사이즈 부합 정렬 준수 확보 점검 여부(aligned), 적정 포맷 오염 값 유무 올바른 초기화 팩트 판별 부합 여부(initialized) 등등 수많은 추가 안전 강박 규제 규약 조항 강령 십계명들을 한가득 덕지 무장 장전 포함 통치 동시 구속 속박 결속 동반 포괄 억견 요구 발동 통제 관할 관장 포함 수용 보장 맹세 강제 의무 제약 서약 선서 약조(assert more properties) 하기에, 이런 막장 포인터 잡동사니 모음 난전 위태 혼잡 시국 똥 판 진흙 오물 구역 혼란 깽판 속에서 그 잘나고 고상 규율 규제 철칙 강제 오지랖 순결 엄격 고결한 안전 참견 증표 조각들을 괜히 멋모르고 마구 날려 찍고 던지 발 투 하 살 남발 남 쑤 남 섞 범 막 함 돌 뿌(wildly throw them around) 댔다간 진짜 그 어떤 재앙 후폭풍 파탄 나락 폭발 자폭 핵 멸 천 멸 대 재 파 멸 멸(dangerous) 사태 환장 파티가 날지 며느리도 절대 장담 보장 확신 책임을 장담할 수 없는 살얼음 데스매치 외줄 도박판 치킨런 꼴이 되기 마련이다.

어쨌든 결론적으로 우리가 할 일은 이렇습니다:
1. 메서드 첫머리 입구에서 안전한 원본 참조자(using the input references)로부터 원시 포인터(our raw pointers)를 뽑아냅니다.
2. 이제부터 이 함수 내에서는 무슨 일이 있어도 오직 생 원시 포인터(only use unsafe pointers)만을 써야 합니다.
3. 작업이 모두 끝날 무렵(at the end) 필요하다면 얌전히 그 원시 포인터들을 다시 안전 참조자로(back to safe pointers) 돌려놓습니다.

다음 장에서 다시 원래의 코드로 복귀해 저 거지 같은 예시 무덤 밭에 또다시 머리를 박고 굴러볼 겁니다.
